Glyph was created wih extensibility in mind. You can freely extend &[glang] by creating or overriding macros, to do whatever you like. Macro definitions are written in pure Ruby code and placed in @.rb@ files within the @lib/macros/@ folder of your project.

tip[Alternatively, you can also define macros right in your document, using the %>[macro:].]

section[header[Anatomy of a Macro]

This is the source code of a fairly simple macro used to format a note :

<notextile>
highlight[=ruby|
macro :note do
  %{<div class="#{@name}"><span class="note-title">#{@name.to_s.capitalize}</span>
		#{@value}

    </div>}
end=]
</notextile>

The @macro@ method takes a single  @Symbol@ or @String@ parameter, corresponding to the name of the macro. In this case, the entire block (or _body_ of the macro) is a @String@ corresponding to what we want the macro to evaluate to: a @<div>@ tag containing a note. 

The body of the macro is evaluated in the context of the =>[http://yardoc.org/docs/glyph/Glyph/Macro|@Glyph::Macro@] class, therefore its instance variables (like codeph[@name] or codeph[@value]) can be used directly.

box[Why using codeph[@name] instead of just "note"?|
For the @note@ macro, it absolutely makes no difference. However, by using codeph[@name] it is possible to re-use the same code for the @tip@, @important@ and @caution@ macros as well, which are in fact only aliases of the @note@ macro:

@macro_alias :important => :note@
@macro_alias :tip => :note@
@macro_alias :caution => :note@
] --[End box]

The following table lists all the instance variables that can be used inside macros:

table[
  tr[
    th[Variable]
    th[Description]
  ]
  tr[
    td[codeph[@node]]
    td[A =>[http://yardoc.org/docs/glyph/Node|@Node@] containing information about the macro, within the document syntax tree. Useful for accessing parent and child macros, and the current =>[http://yardoc.org/docs/glyph/Glyph/Document|@Document@]. Normally, macro nodes contain the following keys:
* @:name@, the name of the macro.
* @:value@, the value (i.e. the contents, within the delimiters) of the macro
* @:source@, a @String@ identifying the source of the macro (a file, a snippet, etc.) 
* @:document@, the parsed document tree.

Note that the first three keys can also be accessed via instance variables.]
  ]
  tr[
    td[codeph[@name]]
    td[The name of the macro]
  ]
  tr[
    td[codeph[@value]]
    td[The full contents (including parameters and nested macros) inside the macro delimiters.]
  ]
  tr[
    td[codeph[@source]]
    td[A @String@ identifying the source of the macro (a file, a snippet, etc.) ]
  ]
  tr[
    td[codeph[@params]]
    td[The parameters passed to the macro. In other words, the value of the macro split by pipes (@\|@).]
  ]
] --[End Table]

]

section[header[Bookmarks and Headers]

The =>[http://yardoc.org/docs/glyph/Glyph/Macro|@Glyph::Macro@] class also includes a few methods to check and store bookmarks and headers. Consider for example the following source code for the %>[anchor]:

<notextile>
highlight[=ruby|
macro :anchor do 
  ident, title = @params
  macro_error "Bookmark '#{ident}' already exists" if bookmark? ident
  bookmark :id => ident, :title => title
  %{<a id="#{ident}">#{title}</a>}
end
=] 
</notextile>

The @bookmark?@ method can be used to check the existance of a particular ID within the whole document, while the @bookmark@ method is used to store bookmark IDs and titles. In a similar way, you can use @header?@ and @header@ methods to check the existance of headers within the documents or store new ones.

]

section[header[Using Placeholders]

Sometimes you may need to access some data that will not be available until the entire document has been fully parsed and analyzed. For example, in order to be able to validate internal links, it is necessary to know in advance if the bookmark ID referenced in the link exists or not, either before (that's easy) or even _after_ the link. 

Here's the source code of the %>[link]:

<notextile>
highlight[=ruby|
macro :link do
  href, title = @params
  if href.match /^#/ then
    anc = href.gsub(/^#/, '').to_sym
    bmk = bookmark? anc
    if bmk then
      title \|\|= bmk[:title]
    else
      plac = placeholder do \|document\|
        macro_error "Bookmark '#{anc}' does not exist" unless document.bookmarks[anc] 
        document.bookmarks[anc][:title]
      end
      title \|\|= plac
    end
  end
  title \|\|= href
  %{<a href="#{href}">#{title}</a>}
end
=]
</notextile>

If there's already a bookmark stored in the current document, then it is possible to retrieve its title and use it as link text. Otherwise, it is necessary to wait until the entire document has been fully processed and then check if the bookmark exists. To do so, use the @placeholder@ method. When called, this method returns an unique placeholder, which is then substituted with the value of the block, right before the document is finalized.

Within the @placeholder@ block, the @document@ parameter is, by all means, the fully analyzed document.
]

section[header[Using Validators]
If you need to make sure that a macro is used properly, consider using =>[http://yardoc.org/docs/glyph/Glyph/Macro/Validators|validators]. These methods can be used anywhere within the macro code to check whether certain conditions are met or not. Some default validators are provided to check the number of parameters of a macro, and they are actually used in some system macros.

If you want to create your own validators, you can call the generic @validate@ method which takes the message to display in case of error, a Hash of options and a block containing the validation to perform.

box[Validating macro placement|
You can, of course, create your own validators to check whether a macro is used within another. While this may seem a good idea to enforce constraints into the way documents are created, it has one major drawback: if you define a macro with such validation, you're effectively limiting its usage, so for example you won't be able to use within snippets or other custom macros.

Suppose, for example, that the %>[header] is only allowed within a @section@ macro. This means that, for example:
* the macro cannot be used within @chapter@ or @appendix@ macros.
* the macro cannot be used in snippets

Even if you consider all the possibilities within the scope of the default macros provided with Glyph, this would also make the @header@ macro unusable within custom macros.
]

]

section[header[Interpreting Glyph Code]

What if you need to evaluate some Glyph code _within_ a macro? Say for example you want to transform a parameter in a link, and you want to make sure that link gets validated exactly like the others, in this case, you can use the @interpret@ method, as follows:

<notextile>
highlight[=ruby|
macro :fmi do
  topic, href = @params
  link = placeholder do \|document\| 
    interpret "link[#{href}]"
  end
  %{<span class="fmi">for more information on #{topic}, see #{link}</span>}
end
=] 
</notextile>

When the @interpret@ method is called, the following happens:
# A new Glyph document is created from the @String@ passed to the method.
# The bookmarks, headers and placeholders are passed from the main document to the new one. Because they are stored in arrays and hashes, they are passed by reference, so for example any new bookmark stored in the new document will also become available in the main document.
# Any macro included in the @String@ is evaluated, and the resulting text is returned by the method. Note that this new document does not get finalized: in other words, placeholders will be left as they are, and they'll eventually be replaced when _the main document_ is finalized.

section[header[Encoding and Decoding Glyph Code|encode_decode]
When you use the @interpret@ method, keep in mind that the code is interpreted _before_ the macro execution ends. This may not always be what you want: if you're nesting macros interpreting @section@ and @header@ macros,for example, your Table of Contents may get messed up, with child sections showing up before their parents. 

To avoid this, you can use the @encode@ and @decode@ methods, as shown in the macros defined for Glyph's =>[http://github.com/h3rald/glyph/blob/master/book/text/changelog.glyph|Changelog]:

<notextile>
highlight[=ruby|
macro :issue do
  exact_parameters 2
  ident, desc = @params
  encode %{
    tr[
      td[\=>[http://github.com/h3rald/glyph/issues/closed#issue/#{ident}\|##{ident}]]
      td[textile[#{desc}]]
    ]
  }
end

macro :features do
  verb = (@name == :features) ? "Implemented" : "Fixed"
  total = @node.children.length
  encode %{
    section[header[#{total} #{@name.to_s.capitalize} #{verb}]
      table[
        tr[
          th[ID]
          th[Description]
        ]
        #@value
      ]
    ]
  }
end

macro :release do
  exact_parameters 3
  number, date, contents = @params
  interpret %{
    section[header[v#{number} &ndash; #{date}]
      #{decode contents}
    ]
  }
end
=]
</notextile>

In this case, @issue@ macros are nested within a @features@ macro, which in turn is nested within a @release@ macro. Note that none of these macros have any side effect: they are just used for text expansion. Because we're always going to nest these macros in this way, there's no to have each one interpret Glyph code: it will be the @release@ macro's job to do so. Instead, the @features@ and @issue@ macros just encode text which will then be decoded by the @release@ macro, before being interpreted. 

When you _encode_ a macro, its delimiters (@\[@, @\]@, and @\|@) will be escaped (into ‡\.‡¤\.91\.¤‡\.‡, ‡\.‡¤\.93\.¤‡\.‡, and ‡\.‡¤\.124\.¤‡\.‡ respectively), and when you _decode_ it, they will be unescaped. In a nutshell, you may want to use the encode/decode mechanism when:
* When you're nesting macros interpreting Glyph code, without side effects.
* When all you want is to copy some Glyph code from child macros into their parents.

note[These methods are also wrapped in the %>[encode] and in the %>[decode].]
]
]

section[header[Further Reading]

For more examples on how to create more complex macros, have a look at the =>[http://github.com/h3rald/glyph/tree/master/macros/|source code] of the existing ones.

To gain a deeper understanding on how macros are executed, have a look at the following Glyph classes:
* =>[http://yardoc.org/docs/glyph/Glyph/Macro|@Glyph::Macro@]
* =>[http://yardoc.org/docs/glyph/Glyph/Interpreter|@Glyph::Interpreter@]
* =>[http://yardoc.org/docs/glyph/Glyph/Document|@Glyph::Document@]
* =>[http://yardoc.org/docs/glyph/Glyph/Node|@Node@]
]
