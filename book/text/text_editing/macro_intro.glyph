section[
@title[Introducing &[macros]]
@id[macro_intro]

By now you probably figured out what a macro looks like: it's an identifier of some kind that wraps a value or parameters within square brackets. More specifically:
* The macro identifier can contain _any_ character except for: @\[@, @\]@, @\\@, @\|@ or spaces.
* The delimiters can be either @\[@ and @\]@ or @\[=@ and @=\]@ (\.fmi[differences between delimiters|#esc_quot]). 
* The value can be anything, even other macros. If a macro supports more than one parameter, they must be separated with @\|@. For example, the %>[link] can take an optional second parameter for the link text: @\..[=link[#link_id\|This is the link text]=]@.

A macro can often have one or more aliases. For example, @=>@ is an alias for the %>[link], so the following macro calls are equivalent:

code[=\.=>[#test\|Test Section]=]
code[=\.link[#test\|Test Section]=]

]

section[
@title[Escaping and Quoting]
@id[esc_quot]

Glyph doesn't require any special control characters like LaTeX, and its macro syntax is very straightforward and liberal. This however comes with a price: because square brackets are used as delimiters, you must escape any square bracket in your text with a backslash. That's not _too_ bad if you think about it, unless you're writing programming code, in which case escaping every single square bracket can be painful.

If a portion of your text contains an excessive amount of square brackets, you may consider using the %>[escape] (or its alias @.@) with the @\[=@ and @=\]@ delimiters. By itself, the escape macro doesn't do anything: it just evaluates to its contents, but the special delimiters act as an escape for any square bracket within them. As a consequence, any macro within @\[=@ and @=\]@ will _not_ be evaluated.

You can use the quoting delimiters with _any_ macro identifier. Obviously, using them as delimiters for things like %>[section]s may not be a good idea, but they should be more or less mandatory with the %>[code], like this:

codeblock[=
code\[=
section[@title[A section]

This is a section.

  section[@title[A nested section]
This is another section.
  ]
]
\=]
=]

note[Although quoting delimiters allow you to use square brackets without escaping them, you must still escape them if you want to escape quoting delimiters themselves.]

Besides square brackets, there are other characters that must or can be escaped with backslashes, as shown in the following table

table[
  tr[
    th[Escape Sequence]
    th[Evaluates to...]
    th[Notes]
  ]
  tr[
    td[@\\\[@]
    td[@\[@]
    td[&[sq_esc]]
  ]
  tr[
    td[@\\\]@]
    td[@\]@]
    td[&[sq_esc]]
  ]
  tr[
    td[@\\\\@]
    td[@\\@]
    td[Backslashes do not have to be escaped by default, but an escaped backslash will evaluate to itself.]
  ]
  tr[
    td[@\\\=@]
    td[@=@]
    td[Equal signs do not have to be escaped by default, but an escaped equal sign will evaluate to iself.]
  ]
  tr[
    td[@\\\|@]
    td[@\|@]
    td[Pipes must be escaped (even within quoting macros) unless they are used to separate macro parameters.]
  ]
  tr[
    td[@\\\..@]
    td[&nbsp;]
    td[An escaped dot evaluates to nothing. Useful to separate macro identifiers from other characters:
code[= _\\..=>[#link\|This link is emphasized using Textile]_ =]
    ]
  ]
]

] --[End section]
